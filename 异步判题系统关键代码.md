# å¼‚æ­¥åˆ¤é¢˜ç³»ç»Ÿå…³é”®ä»£ç 

## ğŸ—ï¸ ç³»ç»Ÿæ¶æ„æ¦‚è§ˆ

å¼‚æ­¥åˆ¤é¢˜ç³»ç»Ÿé‡‡ç”¨ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼ï¼Œé€šè¿‡RabbitMQæ¶ˆæ¯é˜Ÿåˆ—å®ç°ï¼š
- **ç”Ÿäº§è€…**: ä¸»æœåŠ¡ (Flask) - æ¥æ”¶ä»£ç æäº¤ï¼Œå‘é€åˆ¤é¢˜ä»»åŠ¡åˆ°é˜Ÿåˆ—
- **æ¶ˆè´¹è€…**: åˆ¤é¢˜æœåŠ¡ (Worker) - ç›‘å¬é˜Ÿåˆ—ï¼Œå¤„ç†åˆ¤é¢˜ä»»åŠ¡
- **æ¶ˆæ¯é˜Ÿåˆ—**: RabbitMQ - è§£è€¦ç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…ï¼Œæ”¯æŒä»»åŠ¡æŒä¹…åŒ–

## ğŸ“¤ ç”Ÿäº§è€…ç«¯ - ä»£ç æäº¤ (ä¸»æœåŠ¡)

### 1. RabbitMQè¿æ¥é…ç½®
```python
# backend/main-service/app.py

# RabbitMQè¿æ¥é…ç½®
RABBITMQ_HOST = 'localhost'
RABBITMQ_PORT = 5673
QUEUE_NAME = 'judge_queue'

def create_rabbitmq_channel():
    """åˆ›å»ºRabbitMQè¿æ¥é€šé“"""
    connection = pika.BlockingConnection(
        pika.ConnectionParameters(RABBITMQ_HOST, RABBITMQ_PORT)
    )
    return connection.channel()
```

### 2. ä»£ç æäº¤API - å‘é€åˆ¤é¢˜ä»»åŠ¡åˆ°é˜Ÿåˆ—
```python
# backend/main-service/app.py

@app.route('/submit', methods=['POST'])
@token_required
def submit_code(current_user):
    data = request.json
    problem_id = data['problem_id']
    code = data['code']
    language = data['language']
    
    # æ£€æŸ¥é¢˜ç›®æ˜¯å¦å­˜åœ¨
    problem = Problem.query.get(problem_id)
    if not problem or not problem.is_active:
        return jsonify({'error': 'é¢˜ç›®ä¸å­˜åœ¨'}), 404
    
    # åˆ›å»ºæäº¤è®°å½•
    submission = Submission(
        user_id=current_user.id,
        problem_id=problem_id,
        code=code,
        language=language,
        status='pending'  # åˆå§‹çŠ¶æ€ï¼šç­‰å¾…åˆ¤é¢˜
    )
    db.session.add(submission)
    db.session.commit()
    
    # å°è¯•å‘é€åˆ¤é¢˜ä»»åŠ¡åˆ°æ¶ˆæ¯é˜Ÿåˆ—
    rabbitmq_success = False
    try:
        channel = create_rabbitmq_channel()
        channel.queue_declare(queue=QUEUE_NAME, durable=True)  # æŒä¹…åŒ–é˜Ÿåˆ—
        
        # æ„é€ åˆ¤é¢˜ä»»åŠ¡æ¶ˆæ¯
        message = {
            'submission_id': submission.id,
            'problem_id': problem_id,
            'code': code,
            'language': language
        }
        
        # å‘é€æ¶ˆæ¯åˆ°é˜Ÿåˆ—
        channel.basic_publish(
            exchange='',
            routing_key=QUEUE_NAME,
            body=json.dumps(message),
            properties=pika.BasicProperties(delivery_mode=2)  # æ¶ˆæ¯æŒä¹…åŒ–
        )
        rabbitmq_success = True
        channel.close()
        
    except Exception as e:
        print(f"RabbitMQè¿æ¥å¤±è´¥: {str(e)}")
        # ä¸å› RabbitMQå¤±è´¥è€Œè®©æ•´ä¸ªæäº¤å¤±è´¥
        # ä»£ç å·²ä¿å­˜åˆ°æ•°æ®åº“ï¼ŒçŠ¶æ€ä¸ºpending
    
    # è¿”å›æäº¤ç»“æœ
    if rabbitmq_success:
        return jsonify({
            'submission_id': submission.id,
            'status': 'pending',
            'message': 'åˆ¤é¢˜ä»»åŠ¡å·²æäº¤åˆ°é˜Ÿåˆ—'
        }), 202
    else:
        return jsonify({
            'submission_id': submission.id,
            'status': 'pending',
            'message': 'ä»£ç å·²æäº¤ï¼Œä½†åˆ¤é¢˜é˜Ÿåˆ—æš‚æ—¶ä¸å¯ç”¨ï¼Œè¯·ç¨åæŸ¥çœ‹ç»“æœ'
        }), 202
```

### 3. æŸ¥è¯¢åˆ¤é¢˜ç»“æœAPI
```python
# backend/main-service/app.py

@app.route('/result/<int:submission_id>', methods=['GET'])
@token_required
def get_result(current_user, submission_id):
    submission = Submission.query.get(submission_id)
    if not submission:
        return jsonify({'error': 'æäº¤è®°å½•ä¸å­˜åœ¨'}), 404
    
    # æ£€æŸ¥æƒé™ï¼šåªèƒ½æŸ¥çœ‹è‡ªå·±çš„æäº¤æˆ–æ•™å¸ˆå¯ä»¥æŸ¥çœ‹æ‰€æœ‰
    if submission.user_id != current_user.id and current_user.role not in ['teacher', 'admin']:
        return jsonify({'error': 'æƒé™ä¸è¶³'}), 403
    
    return jsonify(submission.to_dict())
```

## ğŸ“¥ æ¶ˆè´¹è€…ç«¯ - åˆ¤é¢˜æœåŠ¡ (Worker)

### 1. åˆ¤é¢˜æœåŠ¡ä¸»é€»è¾‘
```python
# backend/judge-service/judge.py

import pika
import json
from sandbox import run_code
from database import Session

# RabbitMQé…ç½®
RABBITMQ_HOST = 'localhost'
RABBITMQ_PORT = 5673
QUEUE_NAME = 'judge_queue'

def start_judge_worker():
    """å¯åŠ¨åˆ¤é¢˜å·¥ä½œè¿›ç¨‹"""
    try:
        print(f"[*] å°è¯•è¿æ¥åˆ°RabbitMQ: {RABBITMQ_HOST}:{RABBITMQ_PORT}")
        connection = pika.BlockingConnection(
            pika.ConnectionParameters(RABBITMQ_HOST, RABBITMQ_PORT)
        )
        channel = connection.channel()
        channel.queue_declare(queue=QUEUE_NAME, durable=True)
        print(f"[*] æˆåŠŸè¿æ¥åˆ°RabbitMQ: {RABBITMQ_HOST}:{RABBITMQ_PORT}")
        print(f"[*] é˜Ÿåˆ—åç§°: {QUEUE_NAME}")
        
    except Exception as e:
        print(f"[!] RabbitMQè¿æ¥å¤±è´¥: {str(e)}")
        print("[!] åˆ¤é¢˜æœåŠ¡æ— æ³•å¯åŠ¨ï¼Œè¯·æ£€æŸ¥RabbitMQæœåŠ¡çŠ¶æ€")
        return
    
    # å®šä¹‰æ¶ˆæ¯å¤„ç†å›è°ƒå‡½æ•°
    def callback(ch, method, properties, body):
        try:
            # è§£ææ¶ˆæ¯
            data = json.loads(body)
            submission_id = data['submission_id']
            print(f"[*] å¼€å§‹å¤„ç†æäº¤ {submission_id}")
            
            session = Session()
            submission = None
            
            try:
                # è·å–æäº¤è®°å½•
                submission = session.query(Submission).get(submission_id)
                if not submission:
                    print(f"[!] Submission {submission_id} not found")
                    ch.basic_ack(delivery_tag=method.delivery_tag)
                    return
                
                print(f"[*] æäº¤ä¿¡æ¯: ID={submission.id}, é¢˜ç›®ID={submission.problem_id}, çŠ¶æ€={submission.status}")
                
                # æ›´æ–°çŠ¶æ€ä¸ºåˆ¤é¢˜ä¸­
                submission.status = 'judging'
                session.commit()
                print(f"[*] æäº¤ {submission_id} çŠ¶æ€æ›´æ–°ä¸º: judging")
                
                # è·å–é¢˜ç›®ä¿¡æ¯
                problem = session.query(Problem).get(submission.problem_id)
                if not problem:
                    submission.status = 'error'
                    submission.result = 'Problem not found'
                    session.commit()
                    print(f"[!] æäº¤ {submission_id}: é¢˜ç›®ä¸å­˜åœ¨")
                    ch.basic_ack(delivery_tag=method.delivery_tag)
                    return
                
                # æ ¹æ®é¢˜ç›®ç±»å‹è¿›è¡Œä¸åŒçš„åˆ¤é¢˜é€»è¾‘
                if problem.type == 'programming':
                    print(f"[*] è°ƒç”¨ç¼–ç¨‹é¢˜åˆ¤é¢˜å‡½æ•°")
                    result = judge_programming_problem(submission, problem, session)
                elif problem.type == 'choice':
                    print(f"[*] è°ƒç”¨é€‰æ‹©é¢˜åˆ¤é¢˜å‡½æ•°")
                    result = judge_choice_problem(submission, problem, session)
                elif problem.type == 'judge':
                    print(f"[*] è°ƒç”¨åˆ¤æ–­é¢˜åˆ¤é¢˜å‡½æ•°")
                    result = judge_judge_problem(submission, problem, session)
                elif problem.type == 'short_answer':
                    print(f"[*] è°ƒç”¨ç®€ç­”é¢˜åˆ¤é¢˜å‡½æ•°")
                    result = judge_short_answer_problem(submission, problem, session)
                else:
                    submission.status = 'error'
                    submission.result = f'ä¸æ”¯æŒçš„é¢˜ç›®ç±»å‹: {problem.type}'
                    session.commit()
                    print(f"[!] æäº¤ {submission_id}: ä¸æ”¯æŒçš„é¢˜ç›®ç±»å‹ {problem.type}")
                    ch.basic_ack(delivery_tag=method.delivery_tag)
                    return
                
                print(f"[*] æäº¤ {submission_id} åˆ¤é¢˜å®Œæˆï¼ŒçŠ¶æ€: {submission.status}, ç»“æœ: {submission.result}")
                
            except Exception as e:
                print(f"[!] å¤„ç†æäº¤ {submission_id} æ—¶å‘ç”Ÿé”™è¯¯: {str(e)}")
                import traceback
                traceback.print_exc()
                if submission:
                    submission.status = 'error'
                    submission.result = f'åˆ¤é¢˜æœåŠ¡é”™è¯¯: {str(e)}'
                    session.commit()
            finally:
                if session:
                    session.close()
                # ç¡®è®¤æ¶ˆæ¯å·²å¤„ç†
                ch.basic_ack(delivery_tag=method.delivery_tag)
                
        except Exception as e:
            print(f"[!] å›è°ƒå‡½æ•°å‘ç”Ÿé”™è¯¯: {str(e)}")
            import traceback
            traceback.print_exc()
            ch.basic_ack(delivery_tag=method.delivery_tag)
    
    # å¼€å§‹æ¶ˆè´¹é˜Ÿåˆ—
    channel.basic_consume(queue=QUEUE_NAME, on_message_callback=callback)
    print(f"[*] ç­‰å¾…åˆ¤é¢˜ä»»åŠ¡...")
    channel.start_consuming()

if __name__ == '__main__':
    start_judge_worker()
```

### 2. ç¼–ç¨‹é¢˜åˆ¤é¢˜é€»è¾‘
```python
# backend/judge-service/judge.py

def judge_programming_problem(submission, problem, session):
    """åˆ¤é¢˜ç¼–ç¨‹é¢˜ï¼ˆæ”¯æŒå¤šæµ‹è¯•ç”¨ä¾‹ã€ç©ºè¾“å…¥ã€å¤šè¡Œè¾“å…¥/è¾“å‡ºï¼‰"""
    print(f"[*] å¼€å§‹æ‰§è¡Œä»£ç ï¼Œè¯­è¨€: {submission.language}")
    
    # ä¼˜å…ˆå°è¯•è§£æç»“æ„åŒ–JSONæµ‹è¯•ç”¨ä¾‹ï¼š[{"input": "...", "output": "..."}, ...]
    structured_cases = None
    try:
        parsed = json.loads(problem.test_cases) if problem.test_cases else None
        if isinstance(parsed, list) and all(isinstance(c, dict) for c in parsed):
            # è§„èŒƒåŒ–ä¸ºå­—ç¬¦ä¸²
            structured_cases = [
                {
                    'input': (str(c.get('input', '')) if c.get('input') is not None else ''),
                    'output': (str(c.get('output', '')) if c.get('output') is not None else '')
                }
                for c in parsed
            ]
            print(f"[*] è§£æåˆ°ç»“æ„åŒ–æµ‹è¯•ç”¨ä¾‹ {len(structured_cases)} ä¸ª")
    except Exception as e:
        print(f"[!] æµ‹è¯•ç”¨ä¾‹JSONè§£æå¤±è´¥ï¼Œä½¿ç”¨å…¼å®¹æ¨¡å¼: {e}")

    def normalize_text_block(s: str) -> str:
        # ç»Ÿä¸€æ¢è¡Œ/å»é™¤æœ«å°¾å¤šä½™ç©ºç™½è¡Œï¼Œä½†ä¿ç•™ä¸­é—´ç©ºè¡Œ
        if s is None:
            return ''
        # ç»Ÿä¸€æ¢è¡Œ
        s = s.replace('\r\n', '\n').replace('\r', '\n')
        # å»é™¤æ¯è¡Œæœ«å°¾ç©ºæ ¼
        lines = [line.rstrip() for line in s.split('\n')]
        # å»é™¤é¦–å°¾ç©ºè¡Œ
        while lines and lines[0] == '':
            lines.pop(0)
        while lines and lines[-1] == '':
            lines.pop()
        return '\n'.join(lines)

    if structured_cases is not None:
        all_passed = True
        failed_cases = []
        total_execution_time = 0.0

        # éå†æ‰€æœ‰æµ‹è¯•ç”¨ä¾‹
        for i, case in enumerate(structured_cases):
            input_block = case.get('input', '')
            expected_block = case.get('output', '')
            print(f"[*] æ‰§è¡Œç”¨ä¾‹ {i+1}: è¾“å…¥(é¢„è§ˆ)='{input_block[:60]}'â€¦")

            # æ‰§è¡Œä»£ç 
            start_time = time.time()
            output, error = run_code(
                code=submission.code,
                language=submission.language,
                input_data=input_block,
                time_limit_ms=problem.time_limit,
                memory_limit_mb=problem.memory_limit
            )
            exec_time = time.time() - start_time
            total_execution_time = max(total_execution_time, exec_time)

            if error:
                print(f"[*] ç”¨ä¾‹ {i+1} æ‰§è¡Œé”™è¯¯: {error}")
                all_passed = False
                failed_cases.append(f"ç”¨ä¾‹ {i+1}: æ‰§è¡Œé”™è¯¯ - {error}")
                continue

            # æ ‡å‡†åŒ–è¾“å‡ºæ¯”è¾ƒ
            actual_norm = normalize_text_block(output)
            expected_norm = normalize_text_block(expected_block)
            print(f"[*] ç”¨ä¾‹ {i+1} å®é™…è¾“å‡º(é¢„è§ˆ)='{actual_norm[:60]}'â€¦")

            if actual_norm != expected_norm:
                all_passed = False
                failed_cases.append(
                    f"ç”¨ä¾‹ {i+1}: è¾“å‡ºä¸åŒ¹é…\næœŸæœ›: \n{expected_norm}\nå®é™…: \n{actual_norm}"
                )

        # æ›´æ–°åˆ¤é¢˜ç»“æœ
        if all_passed:
            submission.status = 'accepted'
            submission.result = 'æ‰€æœ‰æµ‹è¯•ç”¨ä¾‹é€šè¿‡'
            print(f"[*] æ‰€æœ‰æµ‹è¯•ç”¨ä¾‹é€šè¿‡ï¼")
        else:
            submission.status = 'wrong_answer'
            submission.result = 'éƒ¨åˆ†æµ‹è¯•ç”¨ä¾‹å¤±è´¥:\n' + '\n'.join(failed_cases)
            print(f"[*] éƒ¨åˆ†æµ‹è¯•ç”¨ä¾‹å¤±è´¥")
        
        submission.execution_time = total_execution_time
        session.commit()
        return True
```

## ğŸ”§ æ²™ç®±æ‰§è¡Œç¯å¢ƒ

### 1. æ²™ç®±é…ç½®
```python
# backend/judge-service/sandbox.py

def run_code(code: str, language: str, input_data: str, 
             time_limit_ms: int = 1000, memory_limit_mb: int = 128) -> Tuple[str, Optional[str]]:
    """
    åœ¨æ²™ç®±ç¯å¢ƒä¸­è¿è¡Œç”¨æˆ·ä»£ç 
    
    Args:
        code: ç”¨æˆ·æäº¤çš„ä»£ç 
        language: ç¼–ç¨‹è¯­è¨€
        input_data: è¾“å…¥æ•°æ®
        time_limit_ms: æ—¶é—´é™åˆ¶ï¼ˆæ¯«ç§’ï¼‰
        memory_limit_mb: å†…å­˜é™åˆ¶ï¼ˆMBï¼‰
    
    Returns:
        (output, error)
    """
    try:
        if language == 'python':
            return run_python_code(code, input_data, time_limit_ms, memory_limit_mb)
        elif language == 'cpp':
            return run_cpp_code(code, input_data, time_limit_ms, memory_limit_mb)
        elif language == 'java':
            return run_java_code(code, input_data, time_limit_ms, memory_limit_mb)
        elif language == 'javascript':
            return run_javascript_code(code, input_data, time_limit_ms, memory_limit_mb)
        else:
            raise SandboxError(f"ä¸æ”¯æŒçš„è¯­è¨€: {language}")
    except Exception as e:
        return "", str(e)
```

### 2. Javaä»£ç æ‰§è¡Œç¤ºä¾‹
```python
# backend/judge-service/sandbox.py

def run_java_code(code: str, input_data: str, time_limit_ms: int, memory_limit_mb: int) -> Tuple[str, Optional[str]]:
    """è¿è¡ŒJavaä»£ç """
    # æå–ç±»å
    import re
    class_name = "Main"
    m = re.search(r"public\s+class\s+([A-Za-z_][A-Za-z0-9_]*)", code)
    if not m:
        m = re.search(r"class\s+([A-Za-z_][A-Za-z0-9_]*)", code)
    if m:
        class_name = m.group(1)
    
    # åœ¨ä¸´æ—¶ç›®å½•ä¸‹åˆ›å»ºJavaæ–‡ä»¶
    tmp_dir = tempfile.mkdtemp()
    java_file = os.path.join(tmp_dir, f"{class_name}.java")
    with open(java_file, 'w') as f:
        f.write(code)
    
    # è®¾ç½®Javaç¯å¢ƒå˜é‡
    env = os.environ.copy()
    
    # è‡ªåŠ¨æ£€æµ‹Javaç¯å¢ƒ
    if 'JAVA_HOME' not in env:
        possible_java_homes = [
            '/opt/homebrew/opt/openjdk/libexec/openjdk.jdk/Contents/Home',
            '/Library/Java/JavaVirtualMachines',
            '/System/Library/Java/JavaVirtualMachines',
            '/usr/local/opt/openjdk'
        ]
        
        for java_home in possible_java_homes:
            if os.path.exists(java_home):
                java_bin = os.path.join(java_home, 'bin')
                java_exe = os.path.join(java_bin, 'java')
                if os.path.exists(java_bin) and os.path.exists(java_exe):
                    env['JAVA_HOME'] = java_home
                    break
    
    if 'JAVA_HOME' in env:
        java_bin = os.path.join(env['JAVA_HOME'], 'bin')
        if os.path.exists(java_bin):
            env['PATH'] = java_bin + os.pathsep + env.get('PATH', '')
    
    try:
        # ç¼–è¯‘Javaä»£ç 
        compile_process = subprocess.run(
            ['javac', java_file],
            capture_output=True,
            text=True,
            timeout=10,
            env=env
        )
        
        if compile_process.returncode != 0:
            return "", f"ç¼–è¯‘é”™è¯¯: {compile_process.stderr}"
        
        # è¿è¡Œç¼–è¯‘åçš„ç¨‹åº
        process = subprocess.Popen(
            ['java', '-Xmx' + str(memory_limit_mb) + 'm', class_name],
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            cwd=tmp_dir,
            env=env
        )
        
        try:
            # å¤„ç†è¾“å…¥æ•°æ®
            if input_data is None or (isinstance(input_data, str) and input_data.strip() == ''):
                stdout, stderr = process.communicate(timeout=time_limit_ms / 1000)
            else:
                stdout, stderr = process.communicate(
                    input=input_data,
                    timeout=time_limit_ms / 1000
                )
            
            if process.returncode == 0:
                return stdout.strip(), None
            else:
                return "", stderr.strip()
                
        except subprocess.TimeoutExpired:
            process.kill()
            return "", "æ—¶é—´è¶…é™"
            
    finally:
        # æ¸…ç†ä¸´æ—¶æ–‡ä»¶
        try:
            import shutil
            shutil.rmtree(tmp_dir, ignore_errors=True)
        except:
            pass
```

## ğŸ“Š æ•°æ®æ¨¡å‹

### 1. æäº¤è®°å½•æ¨¡å‹
```python
# backend/shared/models.py

class Submission(Base):
    __tablename__ = 'submission'
    
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey('user.id'))
    problem_id = Column(Integer, ForeignKey('problem.id'))
    code = Column(Text)
    language = Column(String(20))
    status = Column(String(20), default='pending')  # pending, judging, accepted, wrong_answer, error
    result = Column(Text)
    execution_time = Column(Float)
    is_overdue = Column(Boolean, default=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
```

## ğŸš€ å¯åŠ¨å’Œéƒ¨ç½²

### 1. å¯åŠ¨ä¸»æœåŠ¡
```bash
cd backend/main-service
python3 app.py
# ä¸»æœåŠ¡è¿è¡Œåœ¨ç«¯å£5001ï¼Œè´Ÿè´£æ¥æ”¶ä»£ç æäº¤
```

### 2. å¯åŠ¨åˆ¤é¢˜æœåŠ¡
```bash
cd backend/judge-service
python3 judge.py
# åˆ¤é¢˜æœåŠ¡ä½œä¸ºWorkerè¿›ç¨‹ï¼Œç›‘å¬RabbitMQé˜Ÿåˆ—
```

### 3. å¯åŠ¨RabbitMQ
```bash
# ä½¿ç”¨Dockerå¯åŠ¨RabbitMQ
docker run -d --name rabbitmq \
  -p 5673:5672 \
  -p 15673:15672 \
  rabbitmq:3-management

# æˆ–è€…ä½¿ç”¨ç³»ç»ŸåŒ…ç®¡ç†å™¨
brew services start rabbitmq
```

## ğŸ”„ å®Œæ•´æµç¨‹

1. **ç”¨æˆ·æäº¤ä»£ç ** â†’ ä¸»æœåŠ¡æ¥æ”¶ï¼Œåˆ›å»ºSubmissionè®°å½•
2. **å‘é€åˆ¤é¢˜ä»»åŠ¡** â†’ ä¸»æœåŠ¡å°†ä»»åŠ¡å‘é€åˆ°RabbitMQé˜Ÿåˆ—
3. **åˆ¤é¢˜æœåŠ¡å¤„ç†** â†’ Workerè¿›ç¨‹ä»é˜Ÿåˆ—è·å–ä»»åŠ¡ï¼Œæ‰§è¡Œåˆ¤é¢˜
4. **æ›´æ–°ç»“æœ** â†’ åˆ¤é¢˜å®Œæˆåæ›´æ–°æ•°æ®åº“ä¸­çš„SubmissionçŠ¶æ€
5. **ç”¨æˆ·æŸ¥è¯¢ç»“æœ** â†’ é€šè¿‡APIæŸ¥è¯¢åˆ¤é¢˜ç»“æœ

## ğŸ’¡ å…³é”®ç‰¹æ€§

- **å¼‚æ­¥å¤„ç†**: ä»£ç æäº¤ç«‹å³è¿”å›ï¼Œåˆ¤é¢˜åœ¨åå°è¿›è¡Œ
- **ä»»åŠ¡æŒä¹…åŒ–**: ä½¿ç”¨RabbitMQæŒä¹…åŒ–é˜Ÿåˆ—ï¼Œä»»åŠ¡ä¸ä¼šä¸¢å¤±
- **å®¹é”™å¤„ç†**: RabbitMQè¿æ¥å¤±è´¥ä¸å½±å“ä»£ç æäº¤
- **èµ„æºé™åˆ¶**: æ²™ç®±ç¯å¢ƒé™åˆ¶ä»£ç æ‰§è¡Œæ—¶é—´å’Œå†…å­˜ä½¿ç”¨
- **å¤šè¯­è¨€æ”¯æŒ**: æ”¯æŒPythonã€C++ã€Javaã€JavaScriptç­‰
- **æµ‹è¯•ç”¨ä¾‹**: æ”¯æŒå¤šæµ‹è¯•ç”¨ä¾‹ã€ç©ºè¾“å…¥ã€å¤šè¡Œè¾“å…¥è¾“å‡º

---

*æ–‡æ¡£åˆ›å»ºæ—¶é—´: 2024å¹´*
*ç³»ç»Ÿæ¶æ„: ç”Ÿäº§è€…-æ¶ˆè´¹è€… + æ¶ˆæ¯é˜Ÿåˆ—*
*æŠ€æœ¯æ ˆ: Flask + RabbitMQ + Python*
