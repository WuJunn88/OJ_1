# 异步判题系统关键代码

## 🏗️ 系统架构概览

异步判题系统采用生产者-消费者模式，通过RabbitMQ消息队列实现：
- **生产者**: 主服务 (Flask) - 接收代码提交，发送判题任务到队列
- **消费者**: 判题服务 (Worker) - 监听队列，处理判题任务
- **消息队列**: RabbitMQ - 解耦生产者和消费者，支持任务持久化

## 📤 生产者端 - 代码提交 (主服务)

### 1. RabbitMQ连接配置
```python
# backend/main-service/app.py

# RabbitMQ连接配置
RABBITMQ_HOST = 'localhost'
RABBITMQ_PORT = 5673
QUEUE_NAME = 'judge_queue'

def create_rabbitmq_channel():
    """创建RabbitMQ连接通道"""
    connection = pika.BlockingConnection(
        pika.ConnectionParameters(RABBITMQ_HOST, RABBITMQ_PORT)
    )
    return connection.channel()
```

### 2. 代码提交API - 发送判题任务到队列
```python
# backend/main-service/app.py

@app.route('/submit', methods=['POST'])
@token_required
def submit_code(current_user):
    data = request.json
    problem_id = data['problem_id']
    code = data['code']
    language = data['language']
    
    # 检查题目是否存在
    problem = Problem.query.get(problem_id)
    if not problem or not problem.is_active:
        return jsonify({'error': '题目不存在'}), 404
    
    # 创建提交记录
    submission = Submission(
        user_id=current_user.id,
        problem_id=problem_id,
        code=code,
        language=language,
        status='pending'  # 初始状态：等待判题
    )
    db.session.add(submission)
    db.session.commit()
    
    # 尝试发送判题任务到消息队列
    rabbitmq_success = False
    try:
        channel = create_rabbitmq_channel()
        channel.queue_declare(queue=QUEUE_NAME, durable=True)  # 持久化队列
        
        # 构造判题任务消息
        message = {
            'submission_id': submission.id,
            'problem_id': problem_id,
            'code': code,
            'language': language
        }
        
        # 发送消息到队列
        channel.basic_publish(
            exchange='',
            routing_key=QUEUE_NAME,
            body=json.dumps(message),
            properties=pika.BasicProperties(delivery_mode=2)  # 消息持久化
        )
        rabbitmq_success = True
        channel.close()
        
    except Exception as e:
        print(f"RabbitMQ连接失败: {str(e)}")
        # 不因RabbitMQ失败而让整个提交失败
        # 代码已保存到数据库，状态为pending
    
    # 返回提交结果
    if rabbitmq_success:
        return jsonify({
            'submission_id': submission.id,
            'status': 'pending',
            'message': '判题任务已提交到队列'
        }), 202
    else:
        return jsonify({
            'submission_id': submission.id,
            'status': 'pending',
            'message': '代码已提交，但判题队列暂时不可用，请稍后查看结果'
        }), 202
```

### 3. 查询判题结果API
```python
# backend/main-service/app.py

@app.route('/result/<int:submission_id>', methods=['GET'])
@token_required
def get_result(current_user, submission_id):
    submission = Submission.query.get(submission_id)
    if not submission:
        return jsonify({'error': '提交记录不存在'}), 404
    
    # 检查权限：只能查看自己的提交或教师可以查看所有
    if submission.user_id != current_user.id and current_user.role not in ['teacher', 'admin']:
        return jsonify({'error': '权限不足'}), 403
    
    return jsonify(submission.to_dict())
```

## 📥 消费者端 - 判题服务 (Worker)

### 1. 判题服务主逻辑
```python
# backend/judge-service/judge.py

import pika
import json
from sandbox import run_code
from database import Session

# RabbitMQ配置
RABBITMQ_HOST = 'localhost'
RABBITMQ_PORT = 5673
QUEUE_NAME = 'judge_queue'

def start_judge_worker():
    """启动判题工作进程"""
    try:
        print(f"[*] 尝试连接到RabbitMQ: {RABBITMQ_HOST}:{RABBITMQ_PORT}")
        connection = pika.BlockingConnection(
            pika.ConnectionParameters(RABBITMQ_HOST, RABBITMQ_PORT)
        )
        channel = connection.channel()
        channel.queue_declare(queue=QUEUE_NAME, durable=True)
        print(f"[*] 成功连接到RabbitMQ: {RABBITMQ_HOST}:{RABBITMQ_PORT}")
        print(f"[*] 队列名称: {QUEUE_NAME}")
        
    except Exception as e:
        print(f"[!] RabbitMQ连接失败: {str(e)}")
        print("[!] 判题服务无法启动，请检查RabbitMQ服务状态")
        return
    
    # 定义消息处理回调函数
    def callback(ch, method, properties, body):
        try:
            # 解析消息
            data = json.loads(body)
            submission_id = data['submission_id']
            print(f"[*] 开始处理提交 {submission_id}")
            
            session = Session()
            submission = None
            
            try:
                # 获取提交记录
                submission = session.query(Submission).get(submission_id)
                if not submission:
                    print(f"[!] Submission {submission_id} not found")
                    ch.basic_ack(delivery_tag=method.delivery_tag)
                    return
                
                print(f"[*] 提交信息: ID={submission.id}, 题目ID={submission.problem_id}, 状态={submission.status}")
                
                # 更新状态为判题中
                submission.status = 'judging'
                session.commit()
                print(f"[*] 提交 {submission_id} 状态更新为: judging")
                
                # 获取题目信息
                problem = session.query(Problem).get(submission.problem_id)
                if not problem:
                    submission.status = 'error'
                    submission.result = 'Problem not found'
                    session.commit()
                    print(f"[!] 提交 {submission_id}: 题目不存在")
                    ch.basic_ack(delivery_tag=method.delivery_tag)
                    return
                
                # 根据题目类型进行不同的判题逻辑
                if problem.type == 'programming':
                    print(f"[*] 调用编程题判题函数")
                    result = judge_programming_problem(submission, problem, session)
                elif problem.type == 'choice':
                    print(f"[*] 调用选择题判题函数")
                    result = judge_choice_problem(submission, problem, session)
                elif problem.type == 'judge':
                    print(f"[*] 调用判断题判题函数")
                    result = judge_judge_problem(submission, problem, session)
                elif problem.type == 'short_answer':
                    print(f"[*] 调用简答题判题函数")
                    result = judge_short_answer_problem(submission, problem, session)
                else:
                    submission.status = 'error'
                    submission.result = f'不支持的题目类型: {problem.type}'
                    session.commit()
                    print(f"[!] 提交 {submission_id}: 不支持的题目类型 {problem.type}")
                    ch.basic_ack(delivery_tag=method.delivery_tag)
                    return
                
                print(f"[*] 提交 {submission_id} 判题完成，状态: {submission.status}, 结果: {submission.result}")
                
            except Exception as e:
                print(f"[!] 处理提交 {submission_id} 时发生错误: {str(e)}")
                import traceback
                traceback.print_exc()
                if submission:
                    submission.status = 'error'
                    submission.result = f'判题服务错误: {str(e)}'
                    session.commit()
            finally:
                if session:
                    session.close()
                # 确认消息已处理
                ch.basic_ack(delivery_tag=method.delivery_tag)
                
        except Exception as e:
            print(f"[!] 回调函数发生错误: {str(e)}")
            import traceback
            traceback.print_exc()
            ch.basic_ack(delivery_tag=method.delivery_tag)
    
    # 开始消费队列
    channel.basic_consume(queue=QUEUE_NAME, on_message_callback=callback)
    print(f"[*] 等待判题任务...")
    channel.start_consuming()

if __name__ == '__main__':
    start_judge_worker()
```

### 2. 编程题判题逻辑
```python
# backend/judge-service/judge.py

def judge_programming_problem(submission, problem, session):
    """判题编程题（支持多测试用例、空输入、多行输入/输出）"""
    print(f"[*] 开始执行代码，语言: {submission.language}")
    
    # 优先尝试解析结构化JSON测试用例：[{"input": "...", "output": "..."}, ...]
    structured_cases = None
    try:
        parsed = json.loads(problem.test_cases) if problem.test_cases else None
        if isinstance(parsed, list) and all(isinstance(c, dict) for c in parsed):
            # 规范化为字符串
            structured_cases = [
                {
                    'input': (str(c.get('input', '')) if c.get('input') is not None else ''),
                    'output': (str(c.get('output', '')) if c.get('output') is not None else '')
                }
                for c in parsed
            ]
            print(f"[*] 解析到结构化测试用例 {len(structured_cases)} 个")
    except Exception as e:
        print(f"[!] 测试用例JSON解析失败，使用兼容模式: {e}")

    def normalize_text_block(s: str) -> str:
        # 统一换行/去除末尾多余空白行，但保留中间空行
        if s is None:
            return ''
        # 统一换行
        s = s.replace('\r\n', '\n').replace('\r', '\n')
        # 去除每行末尾空格
        lines = [line.rstrip() for line in s.split('\n')]
        # 去除首尾空行
        while lines and lines[0] == '':
            lines.pop(0)
        while lines and lines[-1] == '':
            lines.pop()
        return '\n'.join(lines)

    if structured_cases is not None:
        all_passed = True
        failed_cases = []
        total_execution_time = 0.0

        # 遍历所有测试用例
        for i, case in enumerate(structured_cases):
            input_block = case.get('input', '')
            expected_block = case.get('output', '')
            print(f"[*] 执行用例 {i+1}: 输入(预览)='{input_block[:60]}'…")

            # 执行代码
            start_time = time.time()
            output, error = run_code(
                code=submission.code,
                language=submission.language,
                input_data=input_block,
                time_limit_ms=problem.time_limit,
                memory_limit_mb=problem.memory_limit
            )
            exec_time = time.time() - start_time
            total_execution_time = max(total_execution_time, exec_time)

            if error:
                print(f"[*] 用例 {i+1} 执行错误: {error}")
                all_passed = False
                failed_cases.append(f"用例 {i+1}: 执行错误 - {error}")
                continue

            # 标准化输出比较
            actual_norm = normalize_text_block(output)
            expected_norm = normalize_text_block(expected_block)
            print(f"[*] 用例 {i+1} 实际输出(预览)='{actual_norm[:60]}'…")

            if actual_norm != expected_norm:
                all_passed = False
                failed_cases.append(
                    f"用例 {i+1}: 输出不匹配\n期望: \n{expected_norm}\n实际: \n{actual_norm}"
                )

        # 更新判题结果
        if all_passed:
            submission.status = 'accepted'
            submission.result = '所有测试用例通过'
            print(f"[*] 所有测试用例通过！")
        else:
            submission.status = 'wrong_answer'
            submission.result = '部分测试用例失败:\n' + '\n'.join(failed_cases)
            print(f"[*] 部分测试用例失败")
        
        submission.execution_time = total_execution_time
        session.commit()
        return True
```

## 🔧 沙箱执行环境

### 1. 沙箱配置
```python
# backend/judge-service/sandbox.py

def run_code(code: str, language: str, input_data: str, 
             time_limit_ms: int = 1000, memory_limit_mb: int = 128) -> Tuple[str, Optional[str]]:
    """
    在沙箱环境中运行用户代码
    
    Args:
        code: 用户提交的代码
        language: 编程语言
        input_data: 输入数据
        time_limit_ms: 时间限制（毫秒）
        memory_limit_mb: 内存限制（MB）
    
    Returns:
        (output, error)
    """
    try:
        if language == 'python':
            return run_python_code(code, input_data, time_limit_ms, memory_limit_mb)
        elif language == 'cpp':
            return run_cpp_code(code, input_data, time_limit_ms, memory_limit_mb)
        elif language == 'java':
            return run_java_code(code, input_data, time_limit_ms, memory_limit_mb)
        elif language == 'javascript':
            return run_javascript_code(code, input_data, time_limit_ms, memory_limit_mb)
        else:
            raise SandboxError(f"不支持的语言: {language}")
    except Exception as e:
        return "", str(e)
```

### 2. Java代码执行示例
```python
# backend/judge-service/sandbox.py

def run_java_code(code: str, input_data: str, time_limit_ms: int, memory_limit_mb: int) -> Tuple[str, Optional[str]]:
    """运行Java代码"""
    # 提取类名
    import re
    class_name = "Main"
    m = re.search(r"public\s+class\s+([A-Za-z_][A-Za-z0-9_]*)", code)
    if not m:
        m = re.search(r"class\s+([A-Za-z_][A-Za-z0-9_]*)", code)
    if m:
        class_name = m.group(1)
    
    # 在临时目录下创建Java文件
    tmp_dir = tempfile.mkdtemp()
    java_file = os.path.join(tmp_dir, f"{class_name}.java")
    with open(java_file, 'w') as f:
        f.write(code)
    
    # 设置Java环境变量
    env = os.environ.copy()
    
    # 自动检测Java环境
    if 'JAVA_HOME' not in env:
        possible_java_homes = [
            '/opt/homebrew/opt/openjdk/libexec/openjdk.jdk/Contents/Home',
            '/Library/Java/JavaVirtualMachines',
            '/System/Library/Java/JavaVirtualMachines',
            '/usr/local/opt/openjdk'
        ]
        
        for java_home in possible_java_homes:
            if os.path.exists(java_home):
                java_bin = os.path.join(java_home, 'bin')
                java_exe = os.path.join(java_bin, 'java')
                if os.path.exists(java_bin) and os.path.exists(java_exe):
                    env['JAVA_HOME'] = java_home
                    break
    
    if 'JAVA_HOME' in env:
        java_bin = os.path.join(env['JAVA_HOME'], 'bin')
        if os.path.exists(java_bin):
            env['PATH'] = java_bin + os.pathsep + env.get('PATH', '')
    
    try:
        # 编译Java代码
        compile_process = subprocess.run(
            ['javac', java_file],
            capture_output=True,
            text=True,
            timeout=10,
            env=env
        )
        
        if compile_process.returncode != 0:
            return "", f"编译错误: {compile_process.stderr}"
        
        # 运行编译后的程序
        process = subprocess.Popen(
            ['java', '-Xmx' + str(memory_limit_mb) + 'm', class_name],
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            cwd=tmp_dir,
            env=env
        )
        
        try:
            # 处理输入数据
            if input_data is None or (isinstance(input_data, str) and input_data.strip() == ''):
                stdout, stderr = process.communicate(timeout=time_limit_ms / 1000)
            else:
                stdout, stderr = process.communicate(
                    input=input_data,
                    timeout=time_limit_ms / 1000
                )
            
            if process.returncode == 0:
                return stdout.strip(), None
            else:
                return "", stderr.strip()
                
        except subprocess.TimeoutExpired:
            process.kill()
            return "", "时间超限"
            
    finally:
        # 清理临时文件
        try:
            import shutil
            shutil.rmtree(tmp_dir, ignore_errors=True)
        except:
            pass
```

## 📊 数据模型

### 1. 提交记录模型
```python
# backend/shared/models.py

class Submission(Base):
    __tablename__ = 'submission'
    
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey('user.id'))
    problem_id = Column(Integer, ForeignKey('problem.id'))
    code = Column(Text)
    language = Column(String(20))
    status = Column(String(20), default='pending')  # pending, judging, accepted, wrong_answer, error
    result = Column(Text)
    execution_time = Column(Float)
    is_overdue = Column(Boolean, default=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
```

## 🚀 启动和部署

### 1. 启动主服务
```bash
cd backend/main-service
python3 app.py
# 主服务运行在端口5001，负责接收代码提交
```

### 2. 启动判题服务
```bash
cd backend/judge-service
python3 judge.py
# 判题服务作为Worker进程，监听RabbitMQ队列
```

### 3. 启动RabbitMQ
```bash
# 使用Docker启动RabbitMQ
docker run -d --name rabbitmq \
  -p 5673:5672 \
  -p 15673:15672 \
  rabbitmq:3-management

# 或者使用系统包管理器
brew services start rabbitmq
```

## 🔄 完整流程

1. **用户提交代码** → 主服务接收，创建Submission记录
2. **发送判题任务** → 主服务将任务发送到RabbitMQ队列
3. **判题服务处理** → Worker进程从队列获取任务，执行判题
4. **更新结果** → 判题完成后更新数据库中的Submission状态
5. **用户查询结果** → 通过API查询判题结果

## 💡 关键特性

- **异步处理**: 代码提交立即返回，判题在后台进行
- **任务持久化**: 使用RabbitMQ持久化队列，任务不会丢失
- **容错处理**: RabbitMQ连接失败不影响代码提交
- **资源限制**: 沙箱环境限制代码执行时间和内存使用
- **多语言支持**: 支持Python、C++、Java、JavaScript等
- **测试用例**: 支持多测试用例、空输入、多行输入输出

---

*文档创建时间: 2024年*
*系统架构: 生产者-消费者 + 消息队列*
*技术栈: Flask + RabbitMQ + Python*
